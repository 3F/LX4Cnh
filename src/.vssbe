{
  "Header": {
    "_": [
      " This file for vsSolutionBuildEvent ",
      " https://github.com/3F/vsSolutionBuildEvent "
    ],
    "Compatibility": "0.12.4"
  },
  "PreBuild": [
    {
      "Enabled": true,
      "Name": "Def",
      "Caption": "Define variables etc. ...",
      "Mode": {
        "$type": "net.r_eg.vsSBE.Events.ModeScript, vsSolutionBuildEvent",
        "Type": "Script",
        "Command__": [
          "#[($(Configuration) == \"RCI\") {",
          "    #[$(cfgname = 'Release')]",
          "    $(isPubRel = true)",
          "}",
          "else{",
          "    #[$(cfgname = $(Configuration))]",
          "    $(isPubRel = false)",
          "}]",
          "",
          "#[$(dbin = \"bin/$(cfgname)/\")]",
          "$(odir = \"$(dbin)raw\")",
          "",
          "#[IO delete.directory(\"$(dbin)\", true)]",
          "#[IO copy.directory(\"\", \"$(dbin)\", true)]",
          "",
          "#[IO copy.directory(\"\", \"$(RootObjDir)\", true)]",
          "",
          "$(embdAlgoIn  = \"$(SolutionDir)csharp\\LX4Cnh.cs\")",
          "$(embdAlgoOut = \"$(SolutionDir)$(LX4CnhEmbdOut)\");",
          "",
          "Bug https://github.com/3F/vsSolutionBuildEvent/issues/71",
          "$(OutDirLX4Cnh = \"$(OutDir:LX4Cnh)..\\$(cfgname)\")",
          "",
          "### rev base",
          "",
          "$(revDeltaBase  = \"2021/07/26\")",
          "$(revDeltaMin   = $([System.Math]::Pow(10, 3)))",
          "$(revDeltaMax   = 65534)",
          "",
          "#[var +revBuild]",
          "#[var +bSha1]",
          "",
          "################ Versions",
          "",
          "#[var _versions = #[File get(\"..\\.version\")]]",
          "",
          "#[$(loop = true)]",
          "#[Box iterate(i = 0; $(loop); i += 1): #[try",
          "{    ",
          "    #[var lver = #[$(_versions.Split(\"\\r\"\"\\n\")[$(i)].Trim())]]",
          "    #[try ",
          "    {",
          "        #[( $(lver) != \"\" ) ",
          "        {            ",
          "            #[var vprj  = #[$(lver.Split(':', 2)[0])]]",
          "            ",
          "            #[var v_#[$(vprj)] = #[$(lver.Split(':', 2)[1])]]",
          "        }]",
          "    }",
          "    catch(err, msg){ #[IO writeLine(STDERR): .version processing failed: #[$(msg)] ] }]",
          "}",
          "catch { $(loop = false) }] ]",
          "",
          "",
          "E.g.:",
          "  $(v_algorithm)",
          "  $(v_csharp)"
        ]
      }
    },
    {
      "Enabled": true,
      "Name": "ModulesAndPkg",
      "Caption": "Submodules and dep packages",
      "Mode": {
        "$type": "net.r_eg.vsSBE.Events.ModeScript, vsSolutionBuildEvent",
        "Type": "Script",
        "Command__": [
          "#[\" Packages \"]",
          "",
          "#[( !(#[IO exists.file(\"packages/__checked\")]) )",
          "{",
          "    #[File call(\"$(MSBuildBinPath)\\MSBuild.exe\", \"-t:restore /v:q /nologo /p:Configuration=$(Configuration)\", 1000)]",
          "    ",
          "    #[IO copy.directory(\"\", \"packages/\", true)]",
          "    #[File write(\"packages/__checked\"): ]",
          "}]"
        ]
      }
    },
    {
      "Enabled": true,
      "Name": "ActVer",
      "Caption": "Update versions ...",
      "Mode": {
        "$type": "net.r_eg.vsSBE.Events.ModeScript, vsSolutionBuildEvent",
        "Type": "Script",
        "Command__": [
          "#[($(isPubRel)) ",
          "{",
          "    #[var tBase     = $([System.DateTime]::Parse('$(revDeltaBase)').ToBinary())]",
          "    #[var tNow      = $([System.DateTime]::UtcNow.Ticks)]",
          "    #[var revBuild  = #[$(",
          "        [System.TimeSpan]::FromTicks('$(",
          "            [MSBuild]::Subtract($(tNow), $(tBase))",
          "        )')",
          "        .TotalMinutes.ToString('0')",
          "    )]]",
          "                         ",
          "    #[var revBuild  = #[$(",
          "    ",
          "     [MSBuild]::Add(",
          "         $(revDeltaMin), ",
          "         $([MSBuild]::Modulo(",
          "             $(revBuild), ",
          "             $([MSBuild]::Subtract(",
          "                 $(revDeltaMax), $(revDeltaMin)",
          "              ))",
          "          ))",
          "      )",
          "      ",
          "    )]]",
          "    ",
          "    #[$(pVerBuild = \"$(v_csharp).$(revBuild)\")]",
          "    #[$(pVerBuild0 = $(pVerBuild))]",
          "}",
          "else",
          "{",
          "    #[$(revBuild = 0)]",
          "    #[$(pVerBuild = \"$(v_csharp)\")]",
          "    #[$(pVerBuild0 = \"$(pVerBuild).0\")]",
          "}]",
          "",
          "",
          "#[var tpl = // This code was generated by a vsSolutionBuildEvent. ",
          "// Changes to this file may cause incorrect behavior and will be lost if the code is regenerated.",
          "using System;",
          "",
          "namespace net.r_eg.algorithms",
          "{",
          "    public static class LX4CnhVersion",
          "    {",
          "        public const string PRODUCT = \"%PROD%\";",
          "",
          "        public const string NUMBER = \"%NUM%\";",
          "",
          "        public const string ALGORITHM_CORE = \"%ALGO%\";",
          "",
          "        public const string B_SHA1 = \"%B_SHA1%\";",
          "",
          "        public static readonly Version number = new(NUMBER);",
          "",
          "        public static readonly Version algorithm = new(ALGORITHM_CORE);",
          "    }",
          "}]",
          "",
          "#[\" ",
          "    Checking of the git to define sha1, branch name, etc.",
          "\"]",
          "#[($(isPubRel) ) { #[var isGit = #[IO cmd(\"git rev-parse 2>&1\")]] }else{ #[var -isGit] }]",
          "#[( $(isGit) == \"\" )",
          "{",
          "    #[var bSha1 = #[IO sout(\"git\", \"rev-parse --short HEAD\")]]",
          "    ",
          "    #[$(printVersion = \"$(pVerBuild)+$(bSha1)\")]",
          "    #[$(buildCfg = $(Configuration))]",
          "}",
          "else {",
          "    #[$(bSha1 = '-')]",
          "    #[$(buildCfg = '')]",
          "    #[$(printVersion = \"$(pVerBuild)\")]",
          "}]",
          "",
          "#[var tpl = #[$(tpl.Replace(\"%NUM%\", \"$(pVerBuild)\")",
          "                   .Replace(\"%PROD%\", \"$(printVersion)\")",
          "                   .Replace(\"%ALGO%\", \"$(v_algorithm)\")",
          "                   .Replace(\"%B_SHA1%\", \"$(bSha1)\") )]]",
          "",
          "",
          "#[File write(\"csharp/LX4CnhVersion.cs\"):#[$(tpl.Replace('\\n', '\\r\\n'))]]",
          "",
          "#[IO replace.Regex(\"csharp/LX4Cnh.csproj\", \"<Version>.+?</Version>\", \"<Version>$(v_csharp)</Version>\")]"
        ]
      }
    },
    {
      "Enabled": true,
      "Name": "GenEmbd",
      "Caption": "generate.embedded",
      "Mode": {
        "$type": "net.r_eg.vsSBE.Events.ModeCSharp, vsSolutionBuildEvent",
        "Type": "CSharp",
        "References": [
          "System",
          "System.Linq",
          "System.Core"
        ],
        "SmartReferences": true,
        "GenerateInMemory": true,
        "TreatWarningsAsErrors": false,
        "WarningLevel": 4,
        "FilesMode": false,
        "CachingBytecode": false,
        "LastTime": 0,
        "Command__": [
          "/*",
          "    !!! This is a modified version taken from old GetNuTool project (batch) https://github.com/3F/GetNuTool",
          "    Copyright (c) 2015-2018,2020  Denis Kuzmin <x-3F@outlook.com>",
          "    ",
          "    A quick/dirty adapting was specially for C# LX4Cnh algorithm implementation (n. Embeddable superfast version).",
          "    TODO:",
          "*/",
          "",
          "using System;",
          "using System.IO;",
          "using System.Collections.Generic;",
          "using System.Linq;",
          "using System.Text;",
          "using System.Text.RegularExpressions;",
          "using ICommand = net.r_eg.vsSBE.Actions.ICommand;",
          "using ISolutionEvent = net.r_eg.vsSBE.Events.ISolutionEvent;",
          "",
          "namespace vsSolutionBuildEvent",
          "{",
          "    public class CSharpMode",
          "    {",
          "        public static int Init(ICommand cmd, ISolutionEvent evt)",
          "        {",
          "            string core     = @\"$(embdAlgoIn)\";",
          "            string output   = @\"$(embdAlgoOut)\";",
          "            ",
          "            // -",
          "            ",
          "            Func<char[], int, Func<int, bool>, string[]> gencomb = (char[] _dict, int _size, Func<int, bool> _rule0) =>",
          "            {",
          "                var combination = new char[_size];",
          "                var set         = new List<string>((int)Math.Pow(_dict.Length, _size));",
          "",
          "                int pos = 0;",
          "                Action generator = null;",
          "                generator = () =>",
          "                {",
          "                    for(int i = 0, lim = _size - 1; i < _dict.Length; ++i)",
          "                    {",
          "                        if(pos == 0 && !_rule0(i)) {",
          "                            continue;",
          "                        }",
          "",
          "                        if(pos < lim) {",
          "                            combination[pos] = _dict[i];",
          "                            ++pos;",
          "                            generator();",
          "                            --pos;",
          "                        }",
          "                        else {",
          "                            combination[pos] = _dict[i];",
          "                            set.Add(new String(combination.ToArray()));",
          "                        }",
          "                    }",
          "                };",
          "",
          "                generator();",
          "                return set.ToArray();",
          "            };",
          "",
          "            var variables = new Dictionary<string, string>();",
          "",
          "            var cdict = new[] { 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J',",
          "                                'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T',",
          "                                'U', 'V', 'W', 'X', 'Y', 'z', '0', '1', '2', '3',",
          "                                '4', '5', '6', '7', '8', '9', '_' };",
          "",
          "            Func<int, bool> rule = (int i) => { return char.IsLetter(cdict[i]) || cdict[i] == '_'; };",
          "            var vdict1 = gencomb(cdict, 1, rule);",
          "            var vdict2 = gencomb(cdict, 2, rule);",
          "            ",
          "            var vdict = new string[vdict1.Length + vdict2.Length];",
          "            vdict1.CopyTo(vdict, 0);",
          "            vdict2.CopyTo(vdict, vdict1.Length);",
          "",
          "            // to skip processing for:",
          "            var exvar = new string[] { \"true\", \"false\", \"a\", \"b\", \"c\", \"d\", \"ma\", \"mb\", \"mc\", \"md\", \"high\", \"low\", \"ulong\", \"uint\", \"long\", \"int\", };",
          "",
          "            // https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/",
          "            var rsvwords = new[] { \"do\", \"in\", \"is\", \"as\", \"if\", \"by\", \"on\" };",
          "",
          "            const string VTYPE  = @\"(?:",
          "                                    (?'type'",
          "                                        [a-z_]",
          "                                        [a-z_0-9]+",
          "                                        \\s+",
          "                                    )?",
          "                                    (?'name'[A-Za-z_0-9]+)",
          "                                    \\s*",
          "                                    (?'lim'",
          "                                        \\s*[&!;)=+\\-*><]",
          "                                    )",
          "                                )",
          "                                \";",
          "",
          "            const string VNAME = \"[a-z_0-9]+\"; // [a-z_][a-z_0-9]+",
          "",
          "            using(StreamReader reader = new StreamReader(core, System.Text.Encoding.UTF8, true))",
          "            {",
          "                var content = reader.ReadToEnd();",
          "",
          "                var _c = Regex.Match(content, @\"\\(c\\)\\s*[0-9\\-,;_]+\\s*([^\\r\\n]+)\").Groups[1].Value;",
          "                content = Regex.Replace(content,",
          "                                 @\"[\\s\\S]+\\s",
          "                                   Multiply\\s*\\(.+?\\)",
          "                                   [^{]+\\{",
          "                                       ([\\s\\S]+?)",
          "                                    \\}\\s*/\\*\\*/",
          "                                  [\\s\\S]+\", (Match m) =>",
          "                {",
          "                    string data = m.Groups[1].Value;",
          "",
          "                    // comments",
          "",
          "                    data = Regex.Replace(data, @\"\\s*\\/\\*.+?\\*\\/\\s*\", \"\", RegexOptions.Singleline);",
          "                    data = Regex.Replace(data, @\"\\s*\\/\\/.+?$\", \"\", RegexOptions.Multiline);",
          "",
          "                    variables.Clear();",
          "                    uint uniqVars = 0;",
          "",
          "                    Func<Match, string, string, string, string> shname = delegate(Match _m, string l, string vname, string r)",
          "                    {",
          "                        if(!Regex.IsMatch(vname, \"^[a-z_]\")) {",
          "                            return _m.Value;",
          "                        }",
          "",
          "                        if(exvar.Contains(vname)) {",
          "                            return _m.Value;",
          "                        }",
          "",
          "                        if(variables.ContainsKey(vname)) {",
          "                            return l + variables[vname] + r;",
          "                        }",
          "",
          "                        if(uniqVars + 1 > vdict.Length) {",
          "                            throw new OverflowException(\"vdict does not contain data for new vars\");",
          "                        }",
          "                        ",
          "                        do {",
          "                            variables[vname] = vdict[uniqVars++];",
          "                        } ",
          "                        while(rsvwords.Contains(variables[vname]));",
          "",
          "                        return l + variables[vname] + r;",
          "                    };",
          "",
          "                    data = Regex.Replace",
          "                    (",
          "                        data,",
          "                        VTYPE,",
          "                        (Match _m) =>",
          "                        {",
          "                            var vname = _m.Groups[\"name\"];",
          "                            ",
          "                            if(vname.Success) {",
          "                                return shname(_m, _m.Groups[\"type\"].Value + \" \", vname.Value, _m.Groups[\"lim\"].Value);",
          "                            }",
          "",
          "                            var flambda = _m.Groups[\"flambda\"];",
          "                            if(flambda.Success) {",
          "                                return Regex.Replace(flambda.Value, VNAME, __m => shname(__m, _m.Groups[\"fl\"].Value, __m.Value, \"=>\"));",
          "                            }",
          "",
          "                            var vlambda = _m.Groups[\"vlambda\"];",
          "                            if(vlambda.Success) {",
          "                                return Regex.Replace(vlambda.Value, VNAME, __m => shname(__m, _m.Groups[\"vl\"].Value, __m.Value, \"=>\"));",
          "                            }",
          "",
          "                            return _m.Value;",
          "                        },",
          "                        RegexOptions.IgnorePatternWhitespace | RegexOptions.IgnoreCase",
          "                    );",
          "",
          "                    // using of variables",
          "                    data = Regex.Replace",
          "                    (",
          "                        data,",
          "                        @\"(?'def'^|\\s+in\\s+|(?<==)>|[={};:\\[(,?+\\-])",
          "                            \\s*",
          "                            (?'name'\"+ VNAME + @\")",
          "                            (?'exc'[<>]*)?",
          "                        \", ",
          "                        (Match _m) =>",
          "                        {",
          "                            var def     = _m.Groups[\"def\"].Value;",
          "                            var vname   = _m.Groups[\"name\"].Value;",
          "                            var exc     = _m.Groups[\"exc\"].Value;",
          "",
          "                            if(exc.IndexOfAny(new[] { '<', '>' }) != -1) {",
          "                                return _m.Value;",
          "                            }",
          "",
          "                            if(!Regex.IsMatch(vname, \"^[a-z_]\")) {",
          "                                return _m.Value;",
          "                            }",
          "",
          "                            if(!variables.ContainsKey(vname)) {",
          "                                return def + vname + exc;",
          "                            }",
          "                            return def + variables[vname] + exc;",
          "                        },",
          "                        RegexOptions.IgnorePatternWhitespace | RegexOptions.IgnoreCase | RegexOptions.Multiline",
          "                    );",
          "",
          "                    data = Regex.Replace(data, @\"AbsMinus\\(([\\w]+)\\s*,\\s*([\\w]+)\\s*\\)\\s*;\", \"($1>$2)?$1-$2:$2-$1;\");",
          "                    data = data.Replace(@\"return \", \"high=\");",
          "                    ",
          "                    // CDATA rules",
          "",
          "                    data = Regex.Replace(data, @\"([\\s;},])String([\\s.(]+)\", \"$1string$2\");",
          "                    data = Regex.Replace(data, @\"[sS]tring\\s*\\.\\s*Empty\", \"\\\"\\\"\");",
          "                    data = Regex.Replace(data, @\"\\s*const\\s+[sS]tring\\s+\", \"var \");",
          "                    data = Regex.Replace(data, @\"(?<![,\\( ])[sS]tring\\s+(?'def'[^;]+)\", (_m) => ",
          "                    {",
          "                        var def = _m.Groups[\"def\"].Value;",
          "                        if(def.IndexOf('=') == -1) {",
          "                            return _m.Value;",
          "                        }",
          "                        return \"var \" + def;",
          "                    });",
          "",
          "                    data = Regex.Replace(data, @\"\\s*([{}()=+\\-\\[\\]*?!@,;.])\\s*\", \"$1\");",
          "",
          "                    return data;",
          "                }, ",
          "                RegexOptions.Singleline | RegexOptions.IgnorePatternWhitespace);",
          "",
          "                // common rules",
          "",
          "                content = content.Replace(\"\\r\", \"\").Replace(\"\\n\", \"\");",
          "                content = Regex.Replace(content, @\"\\s{2,}\", \" \");",
          "                content = Regex.Replace(content, @\"\\s*([=,()\\[\\];:.&|{}\\/<>]+)\\s*\", \"$1\");",
          "",
          "                content = content.Replace(\"unchecked{\", \"unchecked{/*LX4Cnh for C# [$(printVersion)] (c) \" + _c + \" */\");",
          "                ",
          "",
          "                using(TextWriter writer = new StreamWriter(output, false, new UTF8Encoding(false))) {",
          "                    writer.Write(content);",
          "                }",
          "            }",
          "",
          "            return 0;",
          "        }",
          "    }",
          "}"
        ]
      }
    },
    {
      "Enabled": true,
      "Name": "UpdEmbd",
      "Caption": "Updated Embeddable superfast version",
      "Mode": {
        "$type": "net.r_eg.vsSBE.Events.ModeScript, vsSolutionBuildEvent",
        "Type": "Script",
        "Command__": [
          "",
          "#[var _embd = #[File get(\"$(embdAlgoOut)\")]]",
          "",
          "#[$(embdtpl = \"unchecked\\{\\/\\*LX4Cnh\\s.+\\}\")]",
          "",
          "#[IO replace.Regex(\"..\\Readme.md\", \"$(embdtpl)\", \"$(_embd)\")]",
          "#[IO replace.Regex(\"csharp\\LX4Cnh.cs\", \"$(embdtpl)\", \"$(_embd)\")]",
          "#[IO replace.Regex(\"tests\\csharp\\Benchmark\\LX4CnhFnvMod.cs\", \"$(embdtpl)\", \"$(_embd)\")]",
          "#[IO replace.Regex(\"tests\\csharp\\Benchmark\\LX4CnhInt128x128.cs\", \"$(embdtpl)\", \"$(_embd)\")]",
          "#[IO replace.Regex(\"tests\\csharp\\UnitTest\\CorrNoHighTest.cs\", \"$(embdtpl)\", \"$(_embd)\")]"
        ]
      }
    },
    {
      "Enabled": true,
      "Name": "ActInfo",
      "Caption": "Compile info",
      "Mode": {
        "$type": "net.r_eg.vsSBE.Events.ModeScript, vsSolutionBuildEvent",
        "Type": "Script",
        "Command__": [
          "#[var buildInfo =  $([System.String]::Concat(\"  \"))",
          "    LX4Cnh core algorithm: #[$(v_algorithm)]",
          "    ",
          "    LX4Cnh for .NET: #[$(printVersion)]",
          "    ",
          "    Configuration:  #[$(Configuration)]",
          "    ",
          "    Platforms:      #[$(TargetFrameworks)]",
          "    ",
          "    ",
          "    :: generated by a vsSolutionBuildEvent #[$(vsSolutionBuildEvent)]",
          "]",
          "",
          "#[( $(isPubRel) ) { ",
          "    #[IO replace.Regex(\"csharp/LX4Cnh.csproj\", \"<BuildInfoVSSBE>[\\s\\S]*?</BuildInfoVSSBE>\", \"<BuildInfoVSSBE>$(buildInfo.Replace('\\n', '\\r\\n'))</BuildInfoVSSBE>\")]",
          "}else{",
          "    #[IO replace.Regex(\"csharp/LX4Cnh.csproj\", \"<BuildInfoVSSBE>[\\s\\S]*?</BuildInfoVSSBE>\", \"<BuildInfoVSSBE></BuildInfoVSSBE>\")]",
          "}]",
          "",
          "#[IO writeLine(\"$(RootObjDir)/build-info.txt\"):#[$(buildInfo.Replace('\\n', '\\r\\n'))]]"
        ]
      }
    }
  ],
  "PostBuild": [
    {
      "Enabled": true,
      "Name": "ActDist",
      "Caption": "Packages etc.",
      "Mode": {
        "$type": "net.r_eg.vsSBE.Events.ModeScript, vsSolutionBuildEvent",
        "Type": "Script",
        "Command__": [
          "#[( $(cfgname) == \"Release\" )",
          "{",
          "    #[IO copy.file(",
          "        {\"..\\License.txt\", \"..\\Readme.md\", \"..\\changelog.txt\", \"..\\.version\", \"$(RootObjDir)/build-info.txt\"}, ",
          "        \"$(odir)/\", true",
          "    )]",
          "    ",
          "    #[$(_targets = $(TargetFrameworks:LX4Cnh))]",
          "    #[$(_loop = true)]",
          "    ",
          "    #[Box iterate(i = 0; $(_loop); i += 1): ",
          "      #[try",
          "      {",
          "        ",
          "        #[$(_target = $(_targets.Split(\";\")[$(i)]))]",
          "        ",
          "        #[IO copy.file",
          "        (",
          "            \"$(OutDirLX4Cnh)/$(_target)/*.*\", ",
          "            \"$(odir)/lib/$(_target)/\", ",
          "            true,",
          "            {\"*.json\"}",
          "        )]",
          "      }",
          "      catch { $(_loop = false) }]",
          "    ]",
          "    ",
          "    #[IO copy.directory(\"\", \"$(odir)/tools/\", true)]",
          "    #[IO copy.file({ \".tools\\gnt.bat\" }, \"$(odir)/tools/\", true)]",
          "    ",
          "    #[IO copy.directory(\"\", \"$(odir)/embd/\", true)]",
          "    #[IO copy.file(\"$(embdAlgoOut)\", \"$(odir)/embd/\", true)]",
          "    ",
          "    #[7z pack.directory(\"$(odir)\", \"$(dbin)LX4Cnh.dotnet.$(printVersion).zip\")]",
          "    ",
          "    ",
          "    #[IO copy.file",
          "    (",
          "        \"$(OutDirLX4Cnh)/*$(v_csharp).nupkg\",",
          "        \"$(dbin)/LX4Cnh.dotnet.$(v_csharp).nupkg\", ",
          "        true ",
          "    )]",
          "}]"
        ]
      }
    }
  ]
}